#!/usr/bin/env python3
"""
üéØ D-Logic AI ÂåÖÊã¨ÁöÑ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà
Êó•Êú¨ÂÖ®ÂõΩ„ÅÆËá™ÁÑ∂Ë®ÄË™û„Éë„Çø„Éº„É≥„Å´„Çà„Çã200È†≠È¶¨Âêç„ÉÜ„Çπ„Éà
"""
import json
import random
import asyncio
import aiohttp
import time
from typing import List, Dict, Any
import sys
import os

sys.path.append(os.path.dirname(__file__))

class ComprehensiveSimulationTest:
    def __init__(self):
        self.knowledge_file = "data/dlogic_raw_knowledge.json"
        self.api_base_url = "http://localhost:8000"
        self.test_results = []
        self.failed_tests = []
        self.success_count = 0
        self.total_tests = 0
        self.horse_list = []
        
    def load_knowledge_base(self) -> List[str]:
        """„Éä„É¨„ÉÉ„Ç∏„Éï„Ç°„Ç§„É´„Åã„ÇâÈ¶¨„ÅÆ„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø"""
        try:
            print("üêé „Éä„É¨„ÉÉ„Ç∏„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÈñãÂßã...")
            with open(self.knowledge_file, 'r', encoding='utf-8') as f:
                knowledge_data = json.load(f)
            
            horses = list(knowledge_data.keys())
            print(f"‚úÖ Á∑èÈ¶¨Êï∞: {len(horses):,}È†≠")
            return horses
            
        except FileNotFoundError:
            print(f"‚ùå „Éä„É¨„ÉÉ„Ç∏„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {self.knowledge_file}")
            return []
        except Exception as e:
            print(f"‚ùå „Éä„É¨„ÉÉ„Ç∏„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: {e}")
            return []
    
    def select_random_horses(self, horses: List[str], count: int = 200) -> List[str]:
        """„É©„É≥„ÉÄ„É†„Å´È¶¨„ÇíÊäΩÂá∫"""
        if len(horses) < count:
            print(f"‚ö†Ô∏è Ë¶ÅÊ±ÇÊï∞({count})„ÅåÁ∑èÈ¶¨Êï∞({len(horses)})„Çà„ÇäÂ§ö„ÅÑ„Åü„ÇÅ„ÄÅÂÖ®È†≠„ÇíÈÅ∏Êäû")
            return horses
        
        selected = random.sample(horses, count)
        print(f"üéØ {count}È†≠„Çí„É©„É≥„ÉÄ„É†ÊäΩÂá∫ÂÆå‰∫Ü")
        return selected
    
    def generate_natural_language_patterns(self) -> Dict[str, List[str]]:
        """Êó•Êú¨ÂÖ®ÂõΩ„ÅÆËá™ÁÑ∂Ë®ÄË™û„Éë„Çø„Éº„É≥„ÇíÁîüÊàê"""
        patterns = {
            # Ê®ôÊ∫ñË™û„ÉªÈñ¢Êù±
            "standard": [
                "{horse}„ÅÆÊåáÊï∞„ÇíÊïô„Åà„Å¶",
                "{horse}„ÅØ„Å©„ÅÜÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶",
                "{horse}„ÅÆÊàêÁ∏æ„ÇíË¶ã„Åõ„Å¶",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô",
                "{horse}„ÇíË™ø„Åπ„Å¶„Åè„Å†„Åï„ÅÑ",
                "{horse}„ÅÆË©ï‰æ°„ÅØÔºü"
            ],
            
            # Èñ¢Ë•øÂºÅ
            "kansai": [
                "{horse}„ÅÆÊåáÊï∞Êïô„Åà„Å¶„Äú",
                "{horse}„ÅØ„Å©„ÅÜ„ÇÑ„ÇìÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„ÇÑ",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Å¶„ÇÇ„Çâ„Åà„ÇãÔºü",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„ÅäÈ°ò„ÅÑ„Åó„Åæ„Å£„Åõ",
                "{horse}Ë™ø„Åπ„Å¶„Åè„Çå„ÇãÔºü",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜ„Å™„ÇìÔºü"
            ],
            
            # Êù±ÂåóÂºÅ
            "tohoku": [
                "{horse}„ÅÆÊåáÊï∞Êïô„Åà„Åß„Åë„Çç",
                "{horse}„ÅØ„Å©„ÅÜ„Å†„ÅπÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„Åë„Çç",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Åß„Åë„Çç",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„Å†",
                "{horse}Ë™ø„Åπ„Åß„ÇÇ„Çâ„Åà„ÇãÔºü",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜ„Å†„ÅπÔºü"
            ],
            
            # ‰πùÂ∑ûÂºÅ
            "kyushu": [
                "{horse}„ÅÆÊåáÊï∞Êïô„Åà„Å¶„Åè„Çå„Çì„Å≠",
                "{horse}„ÅØ„Å©„ÅÜ„Å®Ôºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„Åè„Çå„ÇìÔºü",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Å¶„ÇÇ„Çâ„Åà„Çì„Å≠",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„Åü„ÅÑ",
                "{horse}Ë™ø„Åπ„Å¶„ÇÇ„Çâ„Åà„ÇãÔºü",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜ„Å®Ôºü"
            ],
            
            # ÂåóÊµ∑ÈÅìÂºÅ
            "hokkaido": [
                "{horse}„ÅÆÊåáÊï∞Êïô„Åà„Å¶„Åè„Çå„ÇãÔºü",
                "{horse}„ÅØ„Å©„ÅÜ„Å†„Åπ„ÅïÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„Åè„Çå„Çã„Åπ",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Å¶„ÇÇ„Çâ„Åà„Çã„Å£„Åó„Çá",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô",
                "{horse}Ë™ø„Åπ„Å¶„Åè„Çå„Çã„Åπ„Åï",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜ„Å†„ÅπÔºü"
            ],
            
            # Ê≤ñÁ∏ÑÂºÅ
            "okinawa": [
                "{horse}„ÅÆÊåáÊï∞Êïô„Åà„Å¶„Åè„Çå„Çì„Å≠„Äú",
                "{horse}„ÅØ„Å©„ÅÜ„Å≠„ÄúÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„Åè„Çå„ÇãÔºü",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Å¶„Åè„Çå„Çì„Å≠",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„Åï„Äú",
                "{horse}Ë™ø„Åπ„Å¶„Åè„Çå„ÇãÔºü",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜ„Å≠Ôºü"
            ],
            
            # ‰∏ÅÂØßË™ûÔºàÂ•≥ÊÄßÁöÑÔºâ
            "polite_female": [
                "{horse}„ÅÆÊåáÊï∞„ÇíÊïô„Åà„Å¶„ÅÑ„Åü„Å†„Åë„Åæ„Åõ„Çì„ÅãÔºü",
                "{horse}„ÅØ„ÅÑ„Åã„Åå„Åß„Åó„Çá„ÅÜ„ÅãÔºü",
                "{horse}„Å´„Å§„ÅÑ„Å¶ÂàÜÊûê„Åó„Å¶„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÅãÔºü",
                "{horse}„ÅÆÊàêÁ∏æ„ÇíÊãùË¶ã„Åï„Åõ„Å¶„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÅãÔºü",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢„Çí„ÅäÈ°ò„ÅÑ„ÅÑ„Åü„Åó„Åæ„Åô",
                "{horse}„Çí„ÅäË™ø„Åπ„ÅÑ„Åü„Å†„Åë„Åæ„Åõ„Çì„ÅãÔºü",
                "{horse}„ÅÆË©ï‰æ°„ÅØ„ÅÑ„Åã„Åå„Åß„Åô„ÅãÔºü"
            ],
            
            # „Ç´„Ç∏„É•„Ç¢„É´ÔºàÁî∑ÊÄßÁöÑÔºâ
            "casual_male": [
                "{horse}„ÅÆÊåáÊï∞È†º„ÇÄ",
                "{horse}„Å©„ÅÜ„Å†Ôºü",
                "{horse}ÂàÜÊûê„Åó„Å¶„Åè„Çå",
                "{horse}„ÅÆÊàêÁ∏æË¶ã„Åõ„Çç",
                "{horse}„ÅÆ„Çπ„Ç≥„Ç¢Êïô„Åà„Å¶",
                "{horse}Ë™ø„Åπ„Å¶„Åè„Çå",
                "{horse}„ÅÆË©ï‰æ°„Å©„ÅÜÔºü"
            ]
        }
        
        return patterns
    
    def generate_test_queries(self, horses: List[str]) -> List[Dict[str, Any]]:
        """„ÉÜ„Çπ„ÉàÁî®„ÇØ„Ç®„É™„ÇíÁîüÊàê"""
        patterns = self.generate_natural_language_patterns()
        test_queries = []
        
        print("üó£Ô∏è Ëá™ÁÑ∂Ë®ÄË™û„ÇØ„Ç®„É™ÁîüÊàê‰∏≠...")
        
        for horse in horses:
            # ÂêÑÈ¶¨„Å´ÂØæ„Åó„Å¶Ë§áÊï∞„ÅÆÊñπË®Ä„ÉªË™ûË™ø„Éë„Çø„Éº„É≥„Åß„ÉÜ„Çπ„Éà
            for dialect, pattern_list in patterns.items():
                # ÂêÑÊñπË®Ä„Åã„Çâ1-2„Éë„Çø„Éº„É≥„Çí„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                selected_patterns = random.sample(pattern_list, min(2, len(pattern_list)))
                
                for pattern in selected_patterns:
                    query = pattern.format(horse=horse)
                    test_queries.append({
                        "horse": horse,
                        "query": query,
                        "dialect": dialect,
                        "pattern": pattern
                    })
        
        # „ÉÜ„Çπ„ÉàÊï∞„ÇíË™øÊï¥ÔºàÂ§ö„Åô„Åé„ÇãÂ†¥Âêà„ÅØ‰∏ÄÈÉ®„Çí„Çµ„É≥„Éó„É´Ôºâ
        if len(test_queries) > 1000:  # ÊúÄÂ§ß1000„ÉÜ„Çπ„Éà„Å´Âà∂Èôê
            test_queries = random.sample(test_queries, 1000)
            print(f"‚ö° „ÉÜ„Çπ„ÉàÊï∞„Çí1000„Å´Âà∂Èôê")
        
        print(f"‚úÖ ÁîüÊàêÂÆå‰∫Ü: {len(test_queries)}ÂÄã„ÅÆ„ÉÜ„Çπ„Éà„ÇØ„Ç®„É™")
        return test_queries
    
    async def test_single_query(self, session: aiohttp.ClientSession, test_data: Dict[str, Any]) -> Dict[str, Any]:
        """Âçò‰∏Ä„ÇØ„Ç®„É™„Çí„ÉÜ„Çπ„Éà"""
        query = test_data["query"]
        horse = test_data["horse"]
        dialect = test_data["dialect"]
        
        start_time = time.time()
        
        try:
            # „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâAPI„Å´„É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°
            async with session.post(
                f"{self.api_base_url}/api/chat/message",
                json={"message": query, "history": []},
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                
                if response.status == 200:
                    result = await response.json()
                    end_time = time.time()
                    response_time = end_time - start_time
                    
                    # ÁµêÊûú„ÅÆÊ§úË®º
                    has_d_logic = result.get("has_d_logic", False)
                    horse_name = result.get("horse_name", "")
                    message = result.get("message", "")
                    d_logic_result = result.get("d_logic_result", {})
                    
                    # 12È†ÖÁõÆ„ÉÅ„Çß„ÉÉ„ÇØ
                    detailed_scores = {}
                    if d_logic_result and "horses" in d_logic_result:
                        horses_data = d_logic_result["horses"]
                        if horses_data and len(horses_data) > 0:
                            detailed_scores = horses_data[0].get("detailed_scores", {})
                    
                    twelve_items_count = len(detailed_scores)
                    
                    test_result = {
                        "query": query,
                        "horse": horse,
                        "dialect": dialect,
                        "success": True,
                        "response_time": response_time,
                        "has_d_logic": has_d_logic,
                        "detected_horse": horse_name,
                        "twelve_items_count": twelve_items_count,
                        "message_length": len(message),
                        "status": "‚úÖ"
                    }
                    
                    return test_result
                    
                else:
                    return {
                        "query": query,
                        "horse": horse,
                        "dialect": dialect,
                        "success": False,
                        "error": f"HTTP {response.status}",
                        "response_time": time.time() - start_time,
                        "status": "‚ùå"
                    }
                    
        except asyncio.TimeoutError:
            return {
                "query": query,
                "horse": horse,
                "dialect": dialect,
                "success": False,
                "error": "„Çø„Ç§„É†„Ç¢„Ç¶„Éà",
                "response_time": time.time() - start_time,
                "status": "‚è∞"
            }
        except Exception as e:
            return {
                "query": query,
                "horse": horse,
                "dialect": dialect,
                "success": False,
                "error": str(e),
                "response_time": time.time() - start_time,
                "status": "üí•"
            }
    
    async def run_comprehensive_test(self):
        """ÂåÖÊã¨ÁöÑ„ÉÜ„Çπ„Éà„ÇíÂÆüË°å"""
        print("üöÄ D-Logic AI ÂåÖÊã¨ÁöÑ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„ÉàÈñãÂßã")
        print("=" * 80)
        
        # 1. „Éä„É¨„ÉÉ„Ç∏„Éô„Éº„ÇπË™≠„ÅøËæº„Åø
        horses = self.load_knowledge_base()
        if not horses:
            print("‚ùå „ÉÜ„Çπ„Éà‰∏≠Ê≠¢: „Éä„É¨„ÉÉ„Ç∏„Éï„Ç°„Ç§„É´„ÅåË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì")
            return
        
        # 2. 200È†≠„É©„É≥„ÉÄ„É†ÊäΩÂá∫
        selected_horses = self.select_random_horses(horses, 200)
        self.horse_list = selected_horses
        
        # 3. „ÉÜ„Çπ„Éà„ÇØ„Ç®„É™ÁîüÊàê
        test_queries = self.generate_test_queries(selected_horses)
        self.total_tests = len(test_queries)
        
        print(f"üéØ „ÉÜ„Çπ„ÉàÂØæË±°: {len(selected_horses)}È†≠")
        print(f"üó£Ô∏è „ÉÜ„Çπ„Éà„ÇØ„Ç®„É™: {self.total_tests}ÂÄã")
        print("=" * 80)
        
        # 4. ‰∏¶Ë°å„ÉÜ„Çπ„ÉàÂÆüË°å
        connector = aiohttp.TCPConnector(limit=10, limit_per_host=10)
        timeout = aiohttp.ClientTimeout(total=30)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            print("‚ö° ‰∏¶Ë°å„ÉÜ„Çπ„ÉàÂÆüË°å‰∏≠...")
            
            # „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆöÔºà‰∏ÄÂ∫¶„Å´Âá¶ÁêÜ„Åô„Çã„ÉÜ„Çπ„ÉàÊï∞Ôºâ
            batch_size = 20
            completed_tests = 0
            
            for i in range(0, len(test_queries), batch_size):
                batch = test_queries[i:i + batch_size]
                
                # „Éê„ÉÉ„ÉÅ„Çí‰∏¶Ë°åÂÆüË°å
                tasks = [self.test_single_query(session, test_data) for test_data in batch]
                batch_results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # ÁµêÊûú„ÇíÂá¶ÁêÜ
                for result in batch_results:
                    if isinstance(result, dict):
                        self.test_results.append(result)
                        if result["success"]:
                            self.success_count += 1
                        else:
                            self.failed_tests.append(result)
                    
                    completed_tests += 1
                
                # ÈÄ≤ÊçóË°®Á§∫
                progress = (completed_tests / self.total_tests) * 100
                print(f"üìä ÈÄ≤Êçó: {completed_tests}/{self.total_tests} ({progress:.1f}%)")
                
                # Â∞ë„ÅóÂæÖÊ©üÔºàAPI„Å∏„ÅÆË≤†Ëç∑ËªΩÊ∏õÔºâ
                await asyncio.sleep(0.1)
        
        # 5. ÁµêÊûúÂàÜÊûê
        await self.analyze_results()
    
    async def analyze_results(self):
        """„ÉÜ„Çπ„ÉàÁµêÊûú„ÇíÂàÜÊûê"""
        print("\n" + "=" * 80)
        print("üìä „ÉÜ„Çπ„ÉàÁµêÊûúÂàÜÊûê")
        print("=" * 80)
        
        success_rate = (self.success_count / self.total_tests * 100) if self.total_tests > 0 else 0
        
        print(f"üéØ Á∑è„ÉÜ„Çπ„ÉàÊï∞: {self.total_tests}")
        print(f"‚úÖ ÊàêÂäü: {self.success_count}")
        print(f"‚ùå Â§±Êïó: {len(self.failed_tests)}")
        print(f"üèÜ ÊàêÂäüÁéá: {success_rate:.2f}%")
        print()
        
        # ÂøúÁ≠îÈÄüÂ∫¶ÂàÜÊûê
        successful_tests = [t for t in self.test_results if t["success"]]
        if successful_tests:
            response_times = [t["response_time"] for t in successful_tests]
            avg_response_time = sum(response_times) / len(response_times)
            max_response_time = max(response_times)
            min_response_time = min(response_times)
            
            print("‚ö° ÂøúÁ≠îÈÄüÂ∫¶ÂàÜÊûê:")
            print(f"   Âπ≥Âùá: {avg_response_time:.2f}Áßí")
            print(f"   ÊúÄÈ´ò: {max_response_time:.2f}Áßí") 
            print(f"   ÊúÄ‰Ωé: {min_response_time:.2f}Áßí")
            
            # ÈÄüÂ∫¶Âà•ÂàÜÈ°û
            fast_responses = len([t for t in response_times if t <= 3])
            medium_responses = len([t for t in response_times if 3 < t <= 10])
            slow_responses = len([t for t in response_times if t > 10])
            
            print(f"   È´òÈÄüÔºà3Áßí‰ª•‰∏ãÔºâ: {fast_responses}ÂÄã ({fast_responses/len(successful_tests)*100:.1f}%)")
            print(f"   ‰∏≠ÈÄüÔºà3-10ÁßíÔºâ: {medium_responses}ÂÄã ({medium_responses/len(successful_tests)*100:.1f}%)")
            print(f"   ‰ΩéÈÄüÔºà10ÁßíË∂ÖÔºâ: {slow_responses}ÂÄã ({slow_responses/len(successful_tests)*100:.1f}%)")
        
        print()
        
        # 12È†ÖÁõÆÂàÜÊûê
        twelve_items_tests = [t for t in successful_tests if t.get("twelve_items_count", 0) >= 12]
        twelve_items_rate = (len(twelve_items_tests) / len(successful_tests) * 100) if successful_tests else 0
        print(f"üêé 12È†ÖÁõÆÂÆåÂÖ®Ë®àÁÆóÁéá: {twelve_items_rate:.1f}%")
        
        # ÊñπË®ÄÂà•ÂàÜÊûê
        dialect_stats = {}
        for test in successful_tests:
            dialect = test.get("dialect", "unknown")
            if dialect not in dialect_stats:
                dialect_stats[dialect] = {"count": 0, "total_time": 0}
            dialect_stats[dialect]["count"] += 1
            dialect_stats[dialect]["total_time"] += test["response_time"]
        
        print("\nüó£Ô∏è ÊñπË®ÄÂà•„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ:")
        for dialect, stats in dialect_stats.items():
            avg_time = stats["total_time"] / stats["count"] if stats["count"] > 0 else 0
            print(f"   {dialect}: {stats['count']}„ÉÜ„Çπ„Éà, Âπ≥Âùá{avg_time:.2f}Áßí")
        
        # Â§±Êïó„Ç±„Éº„ÇπÂàÜÊûê
        if self.failed_tests:
            print(f"\n‚ùå Â§±Êïó„Ç±„Éº„ÇπÂàÜÊûê (‰∏ä‰Ωç10‰ª∂):")
            for i, failed in enumerate(self.failed_tests[:10], 1):
                print(f"   {i}. {failed['query']} ‚Üí {failed['error']}")
        
        print("\n" + "=" * 80)
        if success_rate >= 95:
            print("üéâ ÂÑ™ÁßÄÔºÅ„Ç∑„Çπ„ÉÜ„É†„ÅØÈ´ò„ÅÑ‰ø°È†ºÊÄß„ÅßÂãï‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô")
        elif success_rate >= 90:
            print("üëç ËâØÂ•ΩÔºÅÂÆüÁî®ÁöÑ„Å™„É¨„Éô„É´„ÅßÂãï‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô")
        elif success_rate >= 80:
            print("‚ö†Ô∏è ÊôÆÈÄöÔºöÊîπÂñÑ„ÅÆ‰ΩôÂú∞„Åå„ÅÇ„Çä„Åæ„Åô")
        else:
            print("üö® Ë¶ÅÊîπÂñÑÔºöÈáçÂ§ß„Å™ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô")
        
        print("=" * 80)

# „É°„Ç§„É≥ÂÆüË°å
if __name__ == "__main__":
    print("üéØ D-Logic AI ÂåÖÊã¨ÁöÑ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà")
    print("üóæ Êó•Êú¨ÂÖ®ÂõΩ„ÅÆËá™ÁÑ∂Ë®ÄË™û„Éë„Çø„Éº„É≥„Å´„Çà„ÇãÂæπÂ∫ïÊ§úË®º")
    print("üêé 200È†≠„É©„É≥„ÉÄ„É†ÊäΩÂá∫ √ó Â§öÊßò„Å™ÊñπË®Ä„ÉªË™ûË™ø")
    print("=" * 80)
    
    test = ComprehensiveSimulationTest()
    asyncio.run(test.run_comprehensive_test())